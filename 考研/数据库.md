## 语法

- 创建索引 create unique/cluster index table on 属性
- drop index 索引名
- create view as (sql查询语句)
- drop view 视图名
- ctrate table name(name type);
- drop table restrict（删除有限制，不能被引用）/cascade(删除无限制，相应依赖和视图都被删除)
- select  \* from table 单表查询
- distinct 消除重复值
- where 满足条件的元组
- \_ 表示单个字符 % 表示多个字符匹配
- asc 升序 desc 降序
- count 统计
- group by 分组 order by 排序
- left join /right join /inner join
- 嵌套查询 select \* from student where sno in (select sno from sc where cno = ‘2’)
- insert into table(属性) values (value)
- update table set 列名=value where …
- delete from table where ….



## 事务：ACID

> 一组操作序列，且为最小不可分割单位

原子性：事务中要么全部成功，要么一个失败全部失败

一致性：数据库在事务执行前后保持一致性

隔离性：一个事务所做的修改再提交以前对其他事务不可见

持久性：事务一但执行完成，所做修改永远保存在数据库中，即使发生崩溃，执行结果也不会丢失



## 并发产生问题

**脏读**（读取未提交数据）：A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。

**不可重复读**（前后多次读取，数据内容不一致）**事务A在执行读取操作**，由整个事务A比较大，**前后读取同一条数据需要经历很长的时间** 。而在事务A**第一次读取数据**，比如此时读取了小明的年龄为20岁，**事务B执行更改操作**，将小明的年龄更改为30岁，此时**事务A第二次读取**到小明的年龄时，发现其年龄是30岁，**和之前的数据不一样**了，也就是数据不重复了。

**幻读**（前后多次读取，**数据总量不一致**）：事务A在执行读取操作，需要**两次统计数据**的总量，**前一次查询数据总量**后，此时**事务B执行了新增数据**的操作并提交后，这个时候事务**A读取的数据总量和**之前统计的不一样。

**丢失修改**：两个事务T1T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1修改的数据丢失。

## 隔离级别

读未提交：隔离性最差，即使没有提交，对其他事务可见
读已提交：一个事务所作的修改在没提交之前对其他事务不可见
可重复读：保证同一事物读取多次的结果一致，避免脏读，不可重复读，mysql默认隔离级别
串行化： 避免脏读，幻读，不可重复读，缺点效率低，锁表

## 封锁

在对某个数据对象操作之前，像系统发出请求，对其加锁，是实现并发的重要机制

读锁：事务A对数据对象添加读锁后，只能对数据对象进行读的操作，不能修改数据，同时其他事务也可以对该数据对象加读锁，但不能加写锁，直到事务A释放锁。

写锁：事务A对数据对象加上写锁后，其他事务对该数据对象均不能添加锁，除非事务A将锁释放。

## 锁

封锁粒度越大，系统开销就越小，并发小

**活锁**：事务T1封锁了数据R，事务T2请求封锁数据R，T2等待，事务T3请求封锁数据R，T1释放，T3上锁，T4请求这一过程中T2始终在等待，这种现象就叫活锁。

在事务执行过程中，多个事务对同一数据对象进行加锁，总是有一个事务处于等待状态。

解决方案是：采用先来先服务的策略。



**死锁**：两个事务交叉请求资源

死锁预防：

一次封锁法：每个事务必须一次将所有使用的数据加锁，否则不能执行。扩大了封锁范围，降低了并发度

顺序封锁法：对数据对象规定一个封锁顺序，所有事物按照这一顺序实行封锁。

死锁解除：

超时法：超过一定的运行时间即认为发生死锁，可能会产生误判。

等待图法：用图的方式判断是否产生回路，如果产生回路表示发生死锁，其中顶点表示正在运行的事务，边表示事务的等待情况。



一级封锁协议：在修改数据时，添加写锁，防止丢失修改

二级封锁协议：在一级的基础上，添加读锁，防止脏数据

三级封锁协议：二级基础上，添加读锁，避免了不可重复读，防止数据发生改变



意向锁：对一个结点加意向锁，这说明节点的下层节点正在被加锁。

意向读锁：对一个数据对象加意向读锁，表示想要对后裔节点加读锁

意向写锁：对一个数据对象加意向写锁，表示想要对后裔节点加写锁



## 数据库恢复

常见故障

- 事务内部故障：程序本身可以发现
- 系统故障：断电，cpu故障，恢复子系统回滚未正常提交的事务，重新提交已提交的事务
- 介质故障：硬盘损坏，危害最大，重新载入副本
- 计算机病毒：一种人为故障和破坏

恢复技术

- 数据转储：DBA定期的将整个数据库复制到磁带或者另一个磁盘上的过程
  - 静态转储：在没有事务运行时，进行转储
  - 动态转储：运行在转储期间可以修改数据库
- 日志记录，正向扫描日志记录，对发生故障前的事务加入重做队列，对之后的事务加入撤销队列

恢复策略

- 事务：反向扫描日志文件，将数据恢复到更新前的状态，直至事务开始的标记点
- 系统：重做已完成的事务，撤销未完成的事务
- 介质：重装数据库，重做事务

数据库镜像：主从数据库主数据库更新时，将更新后的数据通过dbms自动复制到从属数据库中



## 关系查询处理和查询优化

查询处理

- 查询检查：检查是否满足sql的语法规则
- 查询分析：语句中的数据库对象等是否有效
- 查询优化：选择高效的查询处理策略
  - 代数优化：关系代数表达式的优化
  - 物理优化：存取路径和底层算法的选择
- 查询执行：执行查询代码

## 数据库设计

## 绪论

数据(Data)：数据库存储的基本对象，**描述事物的符号记录**

数据库(DB)：存放数据的仓库

- 永久存储，有组织，可共享的特点

数据库系统：计算机引入数据库之后的系统

数据库管理系统(DBMS):是用户和操作系统之间的一层数据管理软件



数据模型：现实世界**数据特征的抽象**

- **概念模型**：按照**用户的观点**对**数据和信息**进行建模，主要用于数据库设计

  - 实体：客观存在并可相互区别的事物
  - 属性：实体所具有的某一特性
  - 码：唯一标识实体的属性集
  - 域：属性的取值范围
  - 实体型：用实体名和属性名集合来抽象同类实体
  - 实体集：同一类型实体集合
  - 联系：实体内部和实体之间的联系

  > 实体型之间的关系
  >
  > - 一对一
  > - 一对多
  > - 多对多

- **逻辑模型和物理模型**：
  
  - 逻辑模型：层次模型，关系模型，网状模型
  - 物理模型：对数据最底层的抽象，描述**数据在系统内部的表示方法和存取**



数据库三级模式

- 外模式：数据库用户能够看见和使用的**局部数据的逻辑结构**和特征的描述，数据库用户的数据视图
- 模式：数据库中**全体数据的逻辑结构**和特征的描述，所有用户的公共数据视图
- 内模式：一个数据库只有一个内模式，它是**数据物理结构和存储方式的描述**

二级映像

- 外模式-模式：保证了数据的逻辑独立性
- 模式-内模式：保证了数据的物理独立性



数据库系统组成

- 数据库
- 应用系统
- DBA
- DBMS



## 关系数据库

候选码：唯一标识一个元组

主码：多个候选码中，从其中选择一个为主码

关系：一个关系对应通常说的一张表
元组：表中的一行即为一个元组
属性：表中的一列即为一个属性， 给每一个属性起一个名称即属性名
域：属性的取值范围。
分量：元组中的一个属性值。
关系模式：对关系的描述



关系数据模型的操作集合：CRUD



实体完整性：属性A是基本关系R的主属性，则A不能为空

参照完整性：参照的关系中的属性值必须能够在被参照关系找到或者取空值

用户定义完整性：用户自定义的相关约束



# 数据库的安全性和完整性

数据库安全性：保护数据库以防止不合法的使用造成数据泄露,更改和破坏。

### 数据库安全性控制方法

- 用户标识与鉴别：用户密码，口令
- 视图
- 加密

- 存取控制：
  - 自主存取控制（不同数据对象拥有不同的存取权限，也可以将自己的权限授予他人，较为灵活）
  - 强制存取控制（每一个数据对象有一个密级，每一个用户有一个密级，对任意对象，只有合法用户才能存取）



权限控制通过grant和revoke实现授权和撤销



sql特点

综合统一，高度非过程化，面向集合，多种使用方式，简洁易用



### 异常：

冗余数据：一个属性存放在多个表中
修改异常：当你更新数据的时候，数据不能被更新而导致的错误，更新一个自增序列
删除异常：指的是当你需要删除的时候，数据不能被删除而导致的删除错误，如果被引用
插入异常：指插入的数据违反了数据库对象的规定，而导致插入不正确的异常结果，插入元素值的属性个数不相同 



**第一范式**是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复
的属性。

第一范式包括下列指导原则:

- 数组的每个属性只能包含一个值
- 关系中的每个数组必须包含相同数量的值
- 关系中的每个数组一定不能相同

第二范式：满足第一范式的基础上，非主键字段都依赖于主键字段

第三范式：满足第二范式，而且该数据表中的**任何两个非主键字段的数据值之间不存在函数信赖关系**



## mysql 语法

查询：

```mysql
select * from table where name = "zhangsan" order by id desc
select * from table1 left join table2 on table1.id = table2.id 
```

插入数据：

```mysql
insert into tb_name (col_name1，col_name2）values （值1，值2);	
```

删除数据:

```mysql
DDLDTD FROM employee WHDRD id = 3
```

更新数据：

```mysql
UPDATD table SDT name="zhangsan" WHDRD id = 1
```



<img src="D:\notes\images\image-20210204113152648.png" alt="image-20210204113152648" style="zoom:200%;" />





## mysql 引擎

InnoDB：MySQL 默认的事务型存储引擎，实现了四个标准的隔离级别，默认级别是可重复读（RDPDATABLD RDAD）

MyISAM：不支持事务。不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁

事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
外键：InnoDB 支持外键。
备份：InnoDB 支持在线热备份。
崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
其它特性：MyISAM 支持压缩表和空间数据索引。